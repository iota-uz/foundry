---
layout: default
title: Primitive Nodes
parent: Graph Workflow Engine
nav_order: 6
description: 'Low-level building blocks for dynamic, composable workflows'
---

# Primitive Nodes

Low-level building blocks for composing complex, data-driven workflows.

## Overview

Unlike high-level nodes that handle specific tasks, primitives provide simple building blocks that compose into sophisticated patterns:

| Primitive | Purpose | LLM? |
|-----------|---------|------|
| `EvalNode` | Context manipulation, loop control | No |
| `DynamicAgentNode` | Agent with runtime config | Yes |
| `DynamicCommandNode` | Shell with runtime config | No |

## Design Philosophy

**Primitives over abstractions.** Instead of creating a `TaskIteratorNode` that does everything, we provide simple building blocks:

- **EvalNode** for pure state transformation
- **DynamicAgentNode** for AI execution with runtime config
- **DynamicCommandNode** for shell execution with runtime config

Combined with dynamic `next` transitions, these primitives enable any control flow pattern.

---

## EvalNode

Pure context transformation without LLM calls.

### Use Cases

- Loop index management
- Setting/computing derived values
- Array operations (push, filter, map)
- Conditional value assignment
- Accumulating results

### Configuration

```typescript
nodes.EvalNode({
  // Pure function: state in, partial context out
  fn: (state) => ({
    currentIndex: state.context.currentIndex + 1,
    currentTask: state.context.tasks[state.context.currentIndex + 1],
  }),

  // Transition (static or dynamic)
  then: (state) => state.context.currentTask ? 'EXECUTE' : 'DONE',
})
```

### Result Storage

Stores metadata in `state.context.lastEvalResult`:

```typescript
interface EvalResult {
  success: boolean;
  updatedKeys: string[];  // Keys that were updated
  duration: number;       // Execution time in ms
}
```

### Examples

#### Increment Loop Counter

```typescript
INCREMENT: nodes.EvalNode({
  fn: (state) => ({
    currentIndex: state.context.currentIndex + 1,
  }),
  then: 'CHECK_BOUNDS',
}),
```

#### Collect Results

```typescript
COLLECT: nodes.EvalNode({
  fn: (state) => ({
    results: [...state.context.results, state.context.lastAgentResult],
  }),
  then: 'NEXT_ITEM',
}),
```

#### Set Current Item from Array

```typescript
SET_CURRENT: nodes.EvalNode({
  fn: (state) => {
    const idx = state.context.currentIndex;
    return {
      currentTask: state.context.tasks[idx] ?? null,
    };
  },
  then: (state) => state.context.currentTask ? 'PROCESS' : 'DONE',
}),
```

---

## DynamicAgentNode

AI agent with configuration resolved at runtime from workflow state.

### Use Cases

- Dynamic model selection per task
- Prompts generated by previous nodes
- Tool sets that vary based on context
- Per-task system prompts

### Configuration

```typescript
nodes.DynamicAgentNode({
  // Model: static or dynamic
  model: (state) => state.context.currentTask.model,  // 'haiku' | 'sonnet' | 'opus'

  // Prompt: static or dynamic
  prompt: (state) => state.context.currentTask.prompt,

  // Optional system prompt (separate from user prompt)
  system: 'You are a helpful assistant.',

  // Tools: static or dynamic
  tools: (state) => state.context.currentTask.tools ?? ['read_file', 'write_file'],

  // Optional settings
  maxTurns: 10,
  temperature: 0,
  maxTokens: 4096,

  then: 'COLLECT_RESULT',
})
```

### Dynamic Type

All configuration values support the `Dynamic<T>` type:

```typescript
// Static value
model: 'sonnet'

// Dynamic value from state
model: (state) => state.context.currentTask.model
```

### Result Storage

Stores result in `state.context.lastDynamicAgentResult`:

```typescript
interface DynamicAgentResult {
  success: boolean;
  response: string;
  model: string;          // Actual model ID used
  usage: {
    inputTokens: number;
    outputTokens: number;
  };
  error?: string;
  duration: number;
}
```

### Example: Task with Dynamic Model

```typescript
EXECUTE_TASK: nodes.DynamicAgentNode({
  model: (state) => {
    // Use opus for complex tasks, haiku for simple ones
    const task = state.context.currentTask;
    return task.complexity === 'high' ? 'opus' : 'haiku';
  },
  prompt: (state) => state.context.currentTask.prompt,
  tools: ['read_file', 'write_file', 'bash'],
  then: 'VERIFY',
}),
```

---

## DynamicCommandNode

Shell command with configuration resolved at runtime.

### Use Cases

- Commands generated by previous nodes
- Working directories that vary per task
- Environment variables from context
- Dynamic timeouts

### Configuration

```typescript
nodes.DynamicCommandNode({
  // Command: static or dynamic
  command: (state) => state.context.currentTask.command,

  // Working directory: static or dynamic
  cwd: (state) => state.context.projectDir,

  // Environment variables: static or dynamic
  env: (state) => ({
    NODE_ENV: 'test',
    ...state.context.envOverrides,
  }),

  // Timeout in ms: static or dynamic
  timeout: 60000,

  then: 'CHECK_RESULT',
})
```

### Result Storage

Stores result in `state.context.lastDynamicCommandResult`:

```typescript
interface DynamicCommandResult {
  exitCode: number;
  stdout: string;
  stderr: string;
  success: boolean;      // exitCode === 0
  command: string;       // The resolved command
  duration: number;
}
```

### Example: Run Tests for Module

```typescript
RUN_TEST: nodes.DynamicCommandNode({
  command: (state) => `bun test ${state.context.currentModule}`,
  cwd: '/path/to/project',
  timeout: 120000,
  then: (state) => {
    const result = state.context.lastDynamicCommandResult;
    return result?.success ? 'NEXT_MODULE' : 'FIX_TEST';
  },
}),
```

---

## Complete Example: Task Iterator Pattern

This example shows how to iterate over a list of tasks generated by a planning agent, executing each with the specified model.

```typescript
import { defineWorkflow, nodes } from '@sys/graph';

interface Task {
  prompt: string;
  model: 'haiku' | 'sonnet' | 'opus';
}

interface TaskResult {
  success: boolean;
  response: string;
}

interface Context {
  request: string;
  tasks: Task[];
  currentIndex: number;
  currentTask: Task | null;
  results: TaskResult[];
}

// Define the output schema for the planner
const TaskPlanSchema = z.object({
  tasks: z.array(z.object({
    prompt: z.string(),
    model: z.enum(['haiku', 'sonnet', 'opus']),
  })),
});

export default defineWorkflow<Context>({
  id: 'task-iterator',

  initialState: {
    context: {
      request: '',
      tasks: [],
      currentIndex: -1,
      currentTask: null,
      results: [],
    },
  },

  nodes: {
    // 1. Generate task plan
    PLAN: nodes.LLMNode({
      model: 'sonnet',
      system: `You are a task planner. Break down the request into tasks.
Output JSON: { "tasks": [{ "prompt": "...", "model": "haiku"|"sonnet"|"opus" }...] }`,
      prompt: (state) => state.context.request,
      outputSchema: TaskPlanSchema,
      resultKey: 'planResult',
      then: 'INIT_ITERATION',
    }),

    // 2. Initialize iteration
    INIT_ITERATION: nodes.EvalNode({
      fn: (state) => ({
        tasks: state.context.planResult?.output?.tasks ?? [],
        currentIndex: -1,
        results: [],
      }),
      then: 'NEXT_TASK',
    }),

    // 3. Advance to next task
    NEXT_TASK: nodes.EvalNode({
      fn: (state) => {
        const nextIndex = state.context.currentIndex + 1;
        const tasks = state.context.tasks;
        return {
          currentIndex: nextIndex,
          currentTask: tasks[nextIndex] ?? null,
        };
      },
      then: (state) => state.context.currentTask ? 'EXECUTE' : 'FINALIZE',
    }),

    // 4. Execute current task with dynamic model
    EXECUTE: nodes.DynamicAgentNode({
      model: (state) => state.context.currentTask!.model,
      prompt: (state) => state.context.currentTask!.prompt,
      tools: ['read_file', 'write_file', 'bash'],
      then: 'COLLECT_RESULT',
    }),

    // 5. Collect result and loop back
    COLLECT_RESULT: nodes.EvalNode({
      fn: (state) => {
        const agentResult = state.context.lastDynamicAgentResult;
        return {
          results: [
            ...state.context.results,
            {
              success: agentResult?.success ?? false,
              response: agentResult?.response ?? '',
            },
          ],
        };
      },
      then: 'NEXT_TASK',
    }),

    // 6. Final step
    FINALIZE: nodes.CommandNode({
      command: 'bun test',
      then: 'END',
    }),
  },
});
```

---

## Best Practices

### 1. Keep EvalNode Functions Pure

```typescript
// Good: pure function, no side effects
fn: (state) => ({
  count: state.context.count + 1,
})

// Bad: side effects
fn: (state) => {
  console.log('Processing...');  // Side effect
  state.context.count++;          // Mutation
  return state.context;
}
```

### 2. Use Type Guards for Dynamic Values

```typescript
EXECUTE: nodes.DynamicAgentNode({
  model: (state) => {
    const task = state.context.currentTask;
    // Guard against null/undefined
    if (!task) return 'haiku';
    return task.model;
  },
  prompt: (state) => state.context.currentTask?.prompt ?? 'No task',
  then: 'NEXT',
}),
```

### 3. Combine with Dynamic Transitions

```typescript
// EvalNode sets up state, dynamic next handles flow control
ADVANCE: nodes.EvalNode({
  fn: (state) => ({
    index: state.context.index + 1,
    current: state.context.items[state.context.index + 1],
  }),
  then: (state) => {
    if (!state.context.current) return 'DONE';
    if (state.context.current.skip) return 'ADVANCE';  // Skip item
    return 'PROCESS';
  },
}),
```

### 4. Use Descriptive Result Keys

```typescript
// For multiple dynamic agents in a workflow
PLAN: nodes.DynamicAgentNode({
  ...config,
  resultKey: 'planResult',  // Custom key
}),

IMPLEMENT: nodes.DynamicAgentNode({
  ...config,
  resultKey: 'implementResult',  // Different key
}),
```
