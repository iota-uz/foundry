/**
 * @sys/graph - DynamicCommandNode Implementation
 *
 * Shell command node with runtime configuration. Command, cwd, env,
 * and other options can be resolved dynamically from workflow state.
 */

import {
  BaseNode,
  type BaseNodeConfig,
  type NodeExecutionResult,
  NodeExecutionError,
} from '../base';
import type {
  WorkflowState,
  GraphContext,
  Transition,
  Dynamic,
} from '../../types';
import { executeCommand } from '../utils/command-utils';
import { resolveDynamic } from '../utils/dynamic-utils';

/**
 * Result of a DynamicCommandNode execution.
 */
export interface DynamicCommandResult {
  /** Exit code of the command */
  exitCode: number;

  /** Standard output */
  stdout: string;

  /** Standard error output */
  stderr: string;

  /** Whether the command succeeded (exitCode === 0) */
  success: boolean;

  /** The command that was executed */
  command: string;

  /** Execution duration in milliseconds */
  duration: number;
}

/**
 * Configuration for DynamicCommandNode.
 */
export interface DynamicCommandNodeConfig<TContext extends Record<string, unknown>>
  extends BaseNodeConfig<TContext> {
  /**
   * Shell command to execute. Can be static or dynamic.
   *
   * @example
   * ```typescript
   * // Static
   * command: 'bun test'
   *
   * // Dynamic from context
   * command: (state) => state.context.currentTask.command
   * ```
   */
  command: Dynamic<string, TContext>;

  /**
   * Working directory for the command.
   * Can be static or dynamic.
   * Default: current working directory
   */
  cwd?: Dynamic<string, TContext>;

  /**
   * Environment variables to set/override.
   * Can be static or dynamic.
   */
  env?: Dynamic<Record<string, string>, TContext>;

  /**
   * Timeout in milliseconds.
   * Can be static or dynamic.
   * Default: 300000 (5 minutes)
   */
  timeout?: Dynamic<number, TContext>;

  /**
   * Whether to throw on non-zero exit code.
   * Default: true
   */
  throwOnError?: boolean;

  /**
   * Key in context to store the command result.
   * Default: 'lastDynamicCommandResult'
   */
  resultKey?: string;
}


/**
 * DynamicCommandNode - Shell command with runtime configuration.
 *
 * Unlike the static CommandNode, this node resolves command, cwd,
 * env, and timeout at execution time from workflow state. This enables:
 *
 * - Commands generated by previous nodes
 * - Working directories that vary per task
 * - Environment variables from context
 *
 * @example
 * ```typescript
 * // Execute command from context
 * nodes.DynamicCommandNode({
 *   command: (state) => state.context.currentTask.command,
 *   cwd: (state) => state.context.workDir,
 *   next: 'CHECK_RESULT',
 * })
 * ```
 */
export class DynamicCommandNodeRuntime<TContext extends Record<string, unknown>>
  extends BaseNode<TContext, DynamicCommandNodeConfig<TContext>> {

  public readonly nodeType = 'dynamic-command';

  constructor(config: DynamicCommandNodeConfig<TContext>) {
    super({
      ...config,
      throwOnError: config.throwOnError ?? true,
      resultKey: config.resultKey ?? 'lastDynamicCommandResult',
    });
  }

  /**
   * Executes the command with dynamically resolved configuration.
   */
  async execute(
    state: WorkflowState<TContext>,
    context: GraphContext
  ): Promise<NodeExecutionResult<TContext>> {
    const { throwOnError, resultKey } = this.config;

    // Resolve all dynamic values
    const command = resolveDynamic(this.config.command, state);
    const cwd = this.config.cwd ? resolveDynamic(this.config.cwd, state) : undefined;
    const env = this.config.env ? resolveDynamic(this.config.env, state) : undefined;
    const timeout = this.config.timeout
      ? resolveDynamic(this.config.timeout, state)
      : 300000;

    context.logger.info(`[DynamicCommandNode] Executing: ${command}`);

    const startTime = Date.now();

    try {
      const result = await executeCommand(command, { cwd, env, timeout });
      const duration = Date.now() - startTime;

      const commandResult: DynamicCommandResult = {
        ...result,
        command,
        duration,
      };

      context.logger.info(
        `[DynamicCommandNode] Completed with exit code ${result.exitCode} in ${duration}ms`
      );

      // Check for errors
      if (throwOnError && !result.success) {
        throw new NodeExecutionError(
          `Command failed with exit code ${result.exitCode}: ${result.stderr}`,
          command,
          this.nodeType,
          undefined,
          { exitCode: result.exitCode, stderr: result.stderr }
        );
      }

      // Store result in context
      const contextUpdate = {
        ...state.context,
        [resultKey as string]: commandResult,
      } as TContext;

      return {
        stateUpdate: {
          context: contextUpdate,
        },
        metadata: {
          command,
          exitCode: result.exitCode,
          duration,
        },
      };
    } catch (error) {
      const err = error as Error;

      // If it's already a NodeExecutionError, re-throw
      if (err instanceof NodeExecutionError) {
        throw err;
      }

      const duration = Date.now() - startTime;
      throw new NodeExecutionError(
        `Command execution failed: ${err.message}`,
        command,
        this.nodeType,
        err,
        { command, cwd, duration }
      );
    }
  }

}

