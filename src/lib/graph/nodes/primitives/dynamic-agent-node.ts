/**
 * @sys/graph - DynamicAgentNode Implementation
 *
 * Agent node with runtime configuration. Model, prompt, and tools
 * can be resolved dynamically from workflow state at execution time.
 */

import Anthropic from '@anthropic-ai/sdk';
import type { MessageParam } from '@anthropic-ai/sdk/resources/messages';

import {
  BaseNode,
  type BaseNodeConfig,
  type NodeExecutionResult,
  NodeExecutionError,
} from '../base';
import type {
  WorkflowState,
  GraphContext,
  ToolReference,
  Dynamic,
  AgentModel,
} from '../../types';
import { resolveDynamic } from '../utils/dynamic-utils';


/**
 * Result of a DynamicAgentNode execution.
 */
export interface DynamicAgentResult {
  /** Whether the execution succeeded */
  success: boolean;

  /** The agent's response text */
  response: string;

  /** Model that was used */
  model: string;

  /** Token usage */
  usage: {
    inputTokens: number;
    outputTokens: number;
  };

  /** Error message if failed */
  error?: string;

  /** Execution duration in milliseconds */
  duration: number;
}

/**
 * Configuration for DynamicAgentNode.
 */
export interface DynamicAgentNodeConfig<TContext extends Record<string, unknown>>
  extends BaseNodeConfig<TContext> {
  /**
   * Model to use. Can be static or dynamic.
   *
   * @example
   * ```typescript
   * // Static
   * model: 'sonnet'
   *
   * // Dynamic from context
   * model: (state) => state.context.currentTask.model
   * ```
   */
  model: Dynamic<AgentModel, TContext>;

  /**
   * System prompt / user prompt for the agent.
   * Can be static or dynamic.
   *
   * @example
   * ```typescript
   * // Static
   * prompt: 'Analyze the codebase and create a plan.'
   *
   * // Dynamic from context
   * prompt: (state) => state.context.currentTask.prompt
   * ```
   */
  prompt: Dynamic<string, TContext>;

  /**
   * Optional system prompt (separate from user prompt).
   * If not provided, prompt is used as user message with a default system.
   */
  system?: Dynamic<string, TContext>;

  /**
   * Tools available to the agent.
   * Can be static or dynamic.
   *
   * @example
   * ```typescript
   * // Static
   * tools: ['read_file', 'write_file']
   *
   * // Dynamic from context
   * tools: (state) => state.context.currentTask.tools ?? []
   * ```
   */
  tools?: Dynamic<ToolReference[], TContext>;

  /**
   * Maximum turns for the agent loop.
   * Default: 10
   */
  maxTurns?: Dynamic<number, TContext>;

  /**
   * Temperature for generation.
   * Default: 0
   */
  temperature?: Dynamic<number, TContext>;

  /**
   * Maximum tokens to generate.
   * Default: 4096
   */
  maxTokens?: Dynamic<number, TContext>;

  /**
   * Anthropic API key.
   * Falls back to ANTHROPIC_API_KEY environment variable.
   */
  apiKey?: string;

  /**
   * Whether to throw on failure.
   * Default: true
   */
  throwOnError?: boolean;

  /**
   * Key in context to store the result.
   * Default: 'lastDynamicAgentResult'
   */
  resultKey?: string;
}

/**
 * Maps model aliases to actual Anthropic model IDs.
 */
const MODEL_MAP: Record<AgentModel, string> = {
  haiku: 'claude-haiku-4.5',
  sonnet: 'claude-sonnet-4.5',
  opus: 'claude-opus-4.5',
};


/**
 * DynamicAgentNode - Agent with runtime configuration.
 *
 * Unlike the static AgentNode, this node resolves model, prompt,
 * and tools at execution time from workflow state. This enables:
 *
 * - Dynamic model selection per task
 * - Prompts generated by previous nodes
 * - Tool sets that vary based on context
 *
 * @example
 * ```typescript
 * // Execute tasks with dynamic model/prompt from context
 * nodes.DynamicAgentNode({
 *   model: (state) => state.context.currentTask.model,
 *   prompt: (state) => state.context.currentTask.prompt,
 *   tools: ['read_file', 'write_file', 'bash'],
 *   next: 'COLLECT_RESULT',
 * })
 * ```
 */
export class DynamicAgentNodeRuntime<TContext extends Record<string, unknown>>
  extends BaseNode<TContext, DynamicAgentNodeConfig<TContext>> {

  public readonly nodeType = 'dynamic-agent';
  private client: Anthropic | null = null;

  constructor(config: DynamicAgentNodeConfig<TContext>) {
    super({
      ...config,
      throwOnError: config.throwOnError ?? true,
      resultKey: config.resultKey ?? 'lastDynamicAgentResult',
    });
  }

  /**
   * Executes the agent with dynamically resolved configuration.
   */
  async execute(
    state: WorkflowState<TContext>,
    context: GraphContext
  ): Promise<NodeExecutionResult<TContext>> {
    const { apiKey, throwOnError, resultKey } = this.config;

    const startTime = Date.now();

    // Resolve all dynamic values
    const model = resolveDynamic(this.config.model, state);
    const prompt = resolveDynamic(this.config.prompt, state);
    const system = this.config.system !== undefined
      ? resolveDynamic(this.config.system, state)
      : 'You are a helpful AI assistant. Complete the task described in the user message.';
    const tools = this.config.tools !== undefined ? resolveDynamic(this.config.tools, state) : [];
    // TODO: config.maxTurns is defined but not yet implemented (multi-turn agent loops)
    const temperature = this.config.temperature !== undefined
      ? resolveDynamic(this.config.temperature, state)
      : 0;
    const maxTokens = this.config.maxTokens !== undefined
      ? resolveDynamic(this.config.maxTokens, state)
      : 4096;

    const modelId = MODEL_MAP[model];

    context.logger.info(
      `[DynamicAgentNode] Running with model: ${model} (${modelId})`
    );
    context.logger.debug(`[DynamicAgentNode] Prompt: ${prompt.slice(0, 100)}...`);

    try {
      const client = this.getClient(apiKey);

      // Build messages
      const messages: MessageParam[] = [
        { role: 'user', content: prompt },
      ];

      // Build request - for now, simple completion without tool use
      // Tool integration can be added later with Claude Agent SDK
      const requestParams: Anthropic.MessageCreateParams = {
        model: modelId,
        max_tokens: maxTokens,
        system,
        messages,
        temperature,
      };

      // Note: Full tool support would require integrating with Claude Agent SDK
      // For now, we log tool availability but don't execute them
      if (tools.length > 0) {
        context.logger.debug(
          `[DynamicAgentNode] Tools available: ${tools.length} (tool execution requires Agent SDK integration)`
        );
      }

      const response = await client.messages.create(requestParams);
      const duration = Date.now() - startTime;

      // Extract response content
      let responseText = '';
      for (const block of response.content) {
        if (block.type === 'text') {
          responseText += block.text;
        }
      }

      const result: DynamicAgentResult = {
        success: true,
        response: responseText,
        model: modelId,
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
        },
        duration,
      };

      context.logger.info(
        `[DynamicAgentNode] Completed in ${duration}ms ` +
        `(${result.usage.inputTokens}/${result.usage.outputTokens} tokens)`
      );

      // Store result in context
      const contextUpdate = {
        ...state.context,
        [resultKey as string]: result,
      } as TContext;

      return {
        stateUpdate: {
          context: contextUpdate,
        },
        metadata: {
          model: modelId,
          duration,
          usage: result.usage,
        },
      };
    } catch (error) {
      const err = error as Error;
      const duration = Date.now() - startTime;

      const result: DynamicAgentResult = {
        success: false,
        response: '',
        model: modelId,
        usage: { inputTokens: 0, outputTokens: 0 },
        error: err.message,
        duration,
      };

      if (throwOnError === true) {
        throw new NodeExecutionError(
          `Dynamic agent execution failed: ${err.message}`,
          model,
          this.nodeType,
          err,
          { model, duration }
        );
      }

      // Store error result in context
      const contextUpdate = {
        ...state.context,
        [resultKey as string]: result,
      } as TContext;

      return {
        stateUpdate: {
          context: contextUpdate,
        },
        metadata: {
          model: modelId,
          duration,
          error: err.message,
        },
      };
    }
  }

  /**
   * Gets or creates the Anthropic client.
   */
  private getClient(apiKey?: string): Anthropic {
    if (this.client) {
      return this.client;
    }

    const key = apiKey ?? process.env.ANTHROPIC_API_KEY;
    if (key === undefined || key === null || key === '') {
      throw new NodeExecutionError(
        'Anthropic API key not provided. Set apiKey in config or ANTHROPIC_API_KEY env var.',
        'config',
        this.nodeType
      );
    }

    this.client = new Anthropic({ apiKey: key });
    return this.client;
  }
}

